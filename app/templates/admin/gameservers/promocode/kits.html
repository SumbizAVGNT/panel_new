<script>
/* Kits module + автокомплит enchant/attr */
(function(){
  'use strict';

  /* ====== КОНФИГ ====== */
  const SLOT_COUNT = 27;
  const VERSIONS = [
    {
      id: '1.20.6',
      label: 'Vanilla 1.20.6',
      itemsUrl: '/static/data/vanilla-items-1.20.6.json',
      imgUrl: (id) => `/static/mc/1.20.6/items/${id}.png`
    }
  ];
  const ENCH_FILE = '/static/data/enchantments-1.20.6.json';

  /* ====== STATE ====== */
  const state = {
    inited:false,
    items:[],
    version: VERSIONS[0],
    slots: Array(SLOT_COUNT).fill(null), // {id,name,qty,display,extra:{ench:[{id,lvl}],attr:[{id,val,op}]}}
    active:-1,
    ench: { list:[], attrs:[] }, // из json
    dd:{ open:false, idx:-1, data:[] }
  };

  /* ====== DOM ====== */
  const $=(s,r=document)=>r.querySelector(s);
  const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
  let root, grid, itemsWrap, itemsEmpty, verSelect, nameInput, descInput;
  let slotEditor, slotNo, slotQty, slotDName, slotExtra, slotClearBtn, statsPill, kitsToasts;
  let enchInput, enchDD, enchWrap;

  function grab(){
    root = document.getElementById('kits-root');
    if(!root) return false;
    grid       = $('#slot-grid', root);
    itemsWrap  = $('#items-wrap', root);
    itemsEmpty = $('#items-empty', root);
    verSelect  = $('#ver-select', root);
    nameInput  = $('#kit-name', root);
    descInput  = $('#kit-desc', root);

    slotEditor  = $('#slot-editor', root);
    slotNo      = $('#slot-no', root);
    slotQty     = $('#slot-qty', root);
    slotDName   = $('#slot-dname', root);
    slotExtra   = $('#slot-extra', root);
    slotClearBtn= $('#slot-clear', root);
    statsPill   = $('#kit-stats', root);
    kitsToasts  = $('#kits-toasts', root);

    enchInput   = $('#ench-input', root);
    enchDD      = $('#ench-dd', root);
    enchWrap    = $('#slot-enchants', root);

    return true;
  }

  /* ====== Toast ====== */
  function toast(msg, ok=true){
    if(!kitsToasts) return;
    const el=document.createElement('div');
    el.className='toastx '+(ok?'ok':'err');
    el.innerHTML=`<div class="small">${msg}</div>`;
    kitsToasts.appendChild(el);
    setTimeout(()=>{ el.style.opacity='0'; setTimeout(()=>el.remove(), 320); }, 2000);
  }

  /* ====== Items ====== */
  async function loadItemsFor(version){
    state.version = version;
    try{
      const r=await fetch(version.itemsUrl,{cache:'no-store'});
      const j=await r.json();
      let arr=[];
      if(Array.isArray(j)) arr=j;
      else if(Array.isArray(j.items)) arr=j.items;
      else arr=Object.keys(j||{}).map(k=>({id:k,name:j[k]}));
      state.items = arr.filter(x=>x && typeof x.id==='string')
                       .map(x=>({id:x.id, name:x.name || x.id.replaceAll('_',' ')}));
      renderItems();
    }catch(e){
      state.items=[]; renderItems();
      toast('Не удалось загрузить список предметов', false);
    }
  }
  function renderItems(filter=''){
    const q=filter.trim().toLowerCase();
    const list = !q ? state.items : state.items.filter(x =>
      x.id.toLowerCase().includes(q) || (x.name||'').toLowerCase().includes(q));
    itemsWrap.innerHTML=''; itemsEmpty.hidden = list.length>0;
    for(const it of list){
      const col=document.createElement('div'); col.className='col';
      col.innerHTML = `
        <div class="item" draggable="true" title="${it.name}\n${it.id}">
          <img class="icon" src="${state.version.imgUrl(it.id)}" alt="" onerror="this.style.visibility='hidden'">
          <div class="n">${it.name}</div>
        </div>`;
      const div = col.firstElementChild;
      div.addEventListener('dragstart', (e)=>{
        const payload=JSON.stringify({id:it.id,name:it.name});
        e.dataTransfer.setData('application/json', payload);
        e.dataTransfer.setData('text/plain', payload);
      });
      div.addEventListener('click', ()=>{
        const idx = state.active>=0 ? state.active : 0;
        putItemToSlot(idx, it);
      });
      itemsWrap.appendChild(col);
    }
  }

  /* ====== Slots ====== */
  function updateStats(){
    const count = state.slots.filter(Boolean).length;
    statsPill.textContent = `${count} item${count===1?'':'s'}`;
  }
  function buildSlots(){
    grid.innerHTML='';
    for(let i=0;i<SLOT_COUNT;i++){
      const s=document.createElement('div');
      s.className='slot'; s.dataset.idx=String(i);
      s.innerHTML=`<div class="name dim">—</div><div class="qty" hidden>1</div>`;
      s.addEventListener('click', ()=>selectSlot(i));
      s.addEventListener('dragover', e=>{e.preventDefault(); s.classList.add('drag-over');});
      s.addEventListener('dragleave', ()=>s.classList.remove('drag-over'));
      s.addEventListener('drop', e=>{
        e.preventDefault(); s.classList.remove('drag-over');
        try{
          const data = e.dataTransfer.getData('application/json') || e.dataTransfer.getData('text/plain');
          const item = JSON.parse(data); putItemToSlot(i, item);
        }catch(_){}
      });
      grid.appendChild(s);
      renderSlot(i);
    }
    updateStats();
  }
  function renderSlot(i){
    const s=grid.children[i]; if(!s) return;
    const info=state.slots[i];
    if(!info){ s.classList.remove('active'); s.innerHTML=`<div class="name dim">—</div><div class="qty" hidden>1</div>`; return; }
    const img=state.version.imgUrl(info.id);
    const qty=info.qty ?? 1;
    s.innerHTML = `
      <img class="icon" src="${img}" alt="" onerror="this.style.visibility='hidden'">
      <div class="name">${info.display || info.name || info.id}</div>
      <div class="qty"${qty>1?'':" hidden"}>${qty}</div>`;
    s.classList.toggle('active', state.active===i);
  }
  function putItemToSlot(i,item){
    state.slots[i] = { id:item.id, name:item.name, qty:1, extra:{ench:[], attr:[]} };
    renderSlot(i); selectSlot(i); updateStats();
  }
  function selectSlot(i){
    state.active=i;
    $$('.slot',grid).forEach(el=>el.classList.toggle('active', Number(el.dataset.idx)===i));
    const data = state.slots[i];
    slotEditor.hidden=false; slotNo.textContent=String(i+1);
    slotQty.value = data?.qty ?? 1;
    slotDName.value = data?.display ?? '';
    slotClearBtn.disabled = !data;
    // ench chips from extra
    enchWrap.innerHTML='';
    const extra = data?.extra || {ench:[],attr:[]};
    (extra.ench||[]).forEach(addEnchChip);
    (extra.attr||[]).forEach(addAttrChip);
    serializeExtra();
  }
  function clearActiveSlot(){
    if(state.active<0) return;
    state.slots[state.active]=null;
    renderSlot(state.active); selectSlot(state.active); updateStats();
  }
  function applySlotEditor(){
    if(state.active<0) return;
    const s = state.slots[state.active] || (state.slots[state.active]={});
    s.qty = Math.max(1, Math.min(64, Number(slotQty.value||1)));
    s.display = slotDName.value.trim() || '';
    // extra сохраняем из чипсов
    s.extra = parseExtraFromChips();
    serializeExtra();
    renderSlot(state.active); updateStats();
  }

  /* ====== Enchant/Attr: загрузка и поиск ====== */
  async function loadEnchData(){
    try{
      const r=await fetch(ENCH_FILE,{cache:'no-store'}); const j=await r.json();
      state.ench.list  = (j.enchantments||[]).map(e=>({
        id:e.id, t:'ench', alias:(e.alias||[]), max:Number(e.max||1), desc:e.desc||''
      }));
      state.ench.attrs = (j.attributes||[]).map(a=>({
        id:a.id, t:'attr', alias:(a.alias||[]), range:a.range||[-2048,2048], def:a.default ?? 1
      }));
    }catch(e){
      state.ench.list=[]; state.ench.attrs=[];
      toast('Не удалось загрузить список зачарований', false);
    }
  }
  function findSuggestions(q){
    const s=(q||'').toLowerCase();
    const pool=[...state.ench.list, ...state.ench.attrs];
    if(!s) return pool.slice(0,12);
    return pool.filter(x => x.id.includes(s) || (x.alias||[]).some(a=>a.includes(s))).slice(0,12);
  }

  /* ====== Enchant/Attr: UI (чипсы + дропдаун) ====== */
  function openDD(list){
    enchDD.innerHTML = list.map((x,i)=>`
      <div class="dd-item${i===state.dd.idx?' act':''}" data-i="${i}">
        <span>${x.id}</span>
        <small>${x.t==='ench' ? ('max '+x.max) : 'attr'}</small>
      </div>`).join('');
    enchDD.classList.toggle('d-none', list.length===0);
    state.dd.open = list.length>0;
  }
  function closeDD(){ enchDD.classList.add('d-none'); state.dd.open=false; state.dd.idx=-1; }

  function addEnchChip(e){ // e: {id,lvl}
    const chip=document.createElement('span'); chip.className='chip'; chip.dataset.type='ench'; chip.dataset.id=e.id;
    const max = (state.ench.list.find(x=>x.id===e.id)?.max) || 5;
    const lvl = Math.max(1, Math.min(max, Number(e.lvl||1)));
    chip.innerHTML = `
      <span>${e.id}</span>
      <span class="lvl" data-lvl="${lvl}">${lvl}</span>
      <button class="btn" data-act="dec">−</button>
      <button class="btn" data-act="inc">+</button>
      <button class="btn" data-act="del"><i class="bi bi-x"></i></button>`;
    chip.addEventListener('click', (ev)=>{
      const act = ev.target?.dataset?.act; if(!act) return;
      const lvlEl = chip.querySelector('.lvl'); let v=Number(lvlEl.dataset.lvl||1);
      const max = (state.ench.list.find(x=>x.id===e.id)?.max)||5;
      if(act==='inc') v = Math.min(max, v+1);
      if(act==='dec') v = Math.max(1, v-1);
      if(act==='del') { chip.remove(); serializeExtra(); return; }
      lvlEl.dataset.lvl=String(v); lvlEl.textContent=String(v); serializeExtra();
    });
    enchWrap.appendChild(chip);
  }
  function addAttrChip(a){ // a: {id,val,op?}
    const chip=document.createElement('span'); chip.className='chip'; chip.dataset.type='attr'; chip.dataset.id=a.id;
    let val = (a.val==null) ? (state.ench.attrs.find(x=>x.id===a.id)?.def ?? 1) : Number(a.val);
    if(isNaN(val)) val=1;
    chip.innerHTML = `
      <span>${a.id}</span>
      <span class="lvl" data-val="${val}">${val}</span>
      <button class="btn" data-act="dec">−</button>
      <button class="btn" data-act="inc">+</button>
      <button class="btn" data-act="del"><i class="bi bi-x"></i></button>`;
    chip.addEventListener('click', (ev)=>{
      const act = ev.target?.dataset?.act; if(!act) return;
      const lvlEl = chip.querySelector('.lvl'); let v=Number(lvlEl.dataset.val||1);
      const rng = (state.ench.attrs.find(x=>x.id===a.id)?.range)||[-2048,2048];
      const step = Math.abs(rng[1]-rng[0])<=10 ? 0.1 : 1;
      if(act==='inc') v = Math.min(rng[1], +(v+step).toFixed(2));
      if(act==='dec') v = Math.max(rng[0], +(v-step).toFixed(2));
      if(act==='del') { chip.remove(); serializeExtra(); return; }
      lvlEl.dataset.val=String(v); lvlEl.textContent=String(v); serializeExtra();
    });
    enchWrap.appendChild(chip);
  }

  function parseExtraFromChips(){
    const ench=[], attr=[];
    $$('.chip',enchWrap).forEach(ch=>{
      const id=ch.dataset.id, t=ch.dataset.type;
      if(t==='ench'){
        const lvl = Number(ch.querySelector('.lvl').dataset.lvl||1);
        ench.push({id, lvl});
      }else{
        const val = Number(ch.querySelector('.lvl').dataset.val||1);
        attr.push({id, val});
      }
    });
    return {ench, attr};
  }
  function serializeExtra(){
    if(state.active<0) return;
    const s = state.slots[state.active] || {};
    const extra = parseExtraFromChips();
    s.extra = extra;
    slotExtra.value = JSON.stringify(extra); // если нужна строка
    state.slots[state.active] = s;
  }

  /* ====== Bindings ====== */
  function bind(){
    // версия + поиск
    verSelect.innerHTML = VERSIONS.map(v=>`<option value="${v.id}">${v.label}</option>`).join('');
    verSelect.value = state.version.id;
    verSelect.addEventListener('change', ()=>{
      const v = VERSIONS.find(x=>x.id===verSelect.value) || VERSIONS[0];
      loadItemsFor(v);
    });
    $('#item-search',root).addEventListener('input', (e)=>renderItems(e.target.value));
    $('#item-refresh',root).addEventListener('click', ()=>loadItemsFor(state.version));

    // слоты/редактор
    slotClearBtn.addEventListener('click', clearActiveSlot);
    $$('#slot-editor [data-qty]', root).forEach(btn=>{
      btn.addEventListener('click', ()=>{
        let v=Number(slotQty.value||1) + (btn.dataset.qty==='+1'?1:-1);
        v=Math.max(1, Math.min(64, v)); slotQty.value=String(v); applySlotEditor();
      });
    });
    slotQty.addEventListener('input', applySlotEditor);
    slotDName.addEventListener('input', applySlotEditor);

    // автокомплит: ввод
    enchInput.addEventListener('input', ()=>{
      const list = findSuggestions(enchInput.value);
      state.dd.idx = 0; state.dd.data=list; openDD(list);
    });
    enchInput.addEventListener('keydown', (e)=>{
      if(!state.dd.open) return;
      if(e.key==='ArrowDown'){ e.preventDefault(); state.dd.idx=Math.min(state.dd.data.length-1, state.dd.idx+1); openDD(state.dd.data); }
      if(e.key==='ArrowUp'){   e.preventDefault(); state.dd.idx=Math.max(0, state.dd.idx-1); openDD(state.dd.data); }
      if(e.key==='Escape'){ closeDD(); }
      if(e.key==='Enter'){
        e.preventDefault();
        const it=state.dd.data[state.dd.idx]; if(!it) return;
        if(it.t==='ench') addEnchChip({id:it.id, lvl:1});
        else addAttrChip({id:it.id, val:it.def ?? 1});
        enchInput.value=''; closeDD(); serializeExtra();
      }
    });
    // выбор мышкой
    enchDD.addEventListener('click', (e)=>{
      const row = e.target.closest('.dd-item'); if(!row) return;
      const i = Number(row.dataset.i||-1); const it = state.dd.data[i]; if(!it) return;
      if(it.t==='ench') addEnchChip({id:it.id, lvl:1}); else addAttrChip({id:it.id, val:it.def ?? 1});
      enchInput.value=''; closeDD(); serializeExtra();
    });
    document.addEventListener('click', (e)=>{ if(!enchDD.contains(e.target) && e.target!==enchInput) closeDD(); });
  }

  /* ====== INIT ====== */
  window.kitsInit = function kitsInit(){
    if(!grab() || state.inited) return;
    state.inited=true;
    buildSlots();
    bind();
    loadItemsFor(state.version);
    loadEnchData();
  };
  if(document.getElementById('tab-kits')?.classList.contains('active')) window.kitsInit();
})();
</script>
